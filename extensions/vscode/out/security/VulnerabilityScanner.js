"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulnerabilityScanner = void 0;
const CodeAnalyzer_1 = require("../utils/CodeAnalyzer");
class VulnerabilityScanner {
    echoProvider;
    codebaseIndexer;
    codeAnalyzer;
    // Security rules database
    securityRules = new Map();
    // Scan results cache
    scanResults = new Map();
    CACHE_DURATION = 300000; // 5 minutes
    // AI-powered patterns cache
    aiPatterns = new Map();
    // Progress tracking
    currentScan;
    constructor(echoProvider, codebaseIndexer) {
        this.echoProvider = echoProvider;
        this.codebaseIndexer = codebaseIndexer;
        this.codeAnalyzer = new CodeAnalyzer_1.CodeAnalyzer();
        this.initializeSecurityRules();
    }
    async scanWorkspace(options) {
        const scanId = this.generateScanId();
        const startTime = Date.now();
        this.currentScan = {
            id: scanId,
            progress: 0,
            status: 'Initializing security scan...',
            startTime
        };
        try {
            // Get all workspace files
            const workspaceFiles = await this.getWorkspaceFiles();
            const filesToScan = this.filterFilesForScanning(workspaceFiles, options);
            this.updateScanProgress(10, 'Analyzing file structure...');
            // Parallel scanning with batching
            const vulnerabilities = [];
            const batchSize = 10;
            for (let i = 0; i < filesToScan.length; i += batchSize) {
                const batch = filesToScan.slice(i, i + batchSize);
                const progress = 10 + ((i / filesToScan.length) * 80);
                this.updateScanProgress(progress, `Scanning files ${i + 1}-${Math.min(i + batchSize, filesToScan.length)} of ${filesToScan.length}...`);
                const batchResults = await Promise.allSettled(batch.map(file => this.scanFile(file, options)));
                batchResults.forEach(result => {
                    if (result.status === 'fulfilled') {
                        vulnerabilities.push(...result.value);
                    }
                });
            }
            this.updateScanProgress(90, 'AI-powered analysis and validation...');
            // AI enhancement phase
            if (options?.aiEnhanced !== false) {
                const enhancedVulnerabilities = await this.enhanceVulnerabilitiesWithAI(vulnerabilities, filesToScan);
                vulnerabilities.push(...enhancedVulnerabilities);
            }
            this.updateScanProgress(95, 'Generating security report...');
            // Generate comprehensive scan result
            const scanResult = {
                scanId,
                timestamp: Date.now(),
                vulnerabilities: this.deduplicateVulnerabilities(vulnerabilities),
                summary: this.generateSummary(vulnerabilities),
                coverage: {
                    filesScanned: filesToScan.length,
                    linesScanned: filesToScan.reduce((total, file) => total + (file.content?.split('\n').length || 0), 0),
                    functions: filesToScan.reduce((total, file) => total + (file.functions?.length || 0), 0),
                    endpoints: await this.countEndpoints(filesToScan)
                },
                riskScore: this.calculateRiskScore(vulnerabilities),
                complianceStatus: this.assessCompliance(vulnerabilities)
            };
            // Cache result
            this.scanResults.set(scanId, scanResult);
            this.updateScanProgress(100, 'Security scan completed');
            this.currentScan = undefined;
            return scanResult;
        }
        catch (error) {
            console.error('Security scan failed:', error);
            this.currentScan = undefined;
            throw error;
        }
    }
    async scanFile(file, options) {
        if (!file.content)
            return [];
        const vulnerabilities = [];
        // Static analysis with security rules
        vulnerabilities.push(...await this.runStaticAnalysis(file));
        // Pattern-based detection
        vulnerabilities.push(...await this.runPatternDetection(file));
        // Language-specific analysis
        vulnerabilities.push(...await this.runLanguageSpecificAnalysis(file));
        // Data flow analysis for complex vulnerabilities
        vulnerabilities.push(...await this.runDataFlowAnalysis(file));
        return vulnerabilities;
    }
    async runStaticAnalysis(file) {
        const vulnerabilities = [];
        const lines = file.content.split('\n');
        for (const [ruleId, rule] of this.securityRules) {
            if (!rule.enabled || !rule.languages.includes(file.languageId)) {
                continue;
            }
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                const match = typeof rule.pattern === 'string'
                    ? line.includes(rule.pattern)
                    : rule.pattern.test(line);
                if (match) {
                    const vulnerability = await this.createVulnerability(rule, file, lineIndex + 1, line);
                    if (vulnerability) {
                        vulnerabilities.push(vulnerability);
                    }
                }
            }
        }
        return vulnerabilities;
    }
    async runPatternDetection(file) {
        const vulnerabilities = [];
        const content = file.content;
        // SQL Injection patterns
        const sqlInjectionPatterns = [
            /execute\s*\(\s*["'].*?\+.*?["']\s*\)/gi,
            /query\s*\(\s*["'].*?\+.*?["']\s*\)/gi,
            /sql\s*=\s*["'].*?\+.*?["']/gi,
            /SELECT\s+.*?\+.*?FROM/gi,
            /INSERT\s+.*?\+.*?VALUES/gi,
            /UPDATE\s+.*?\+.*?SET/gi,
            /DELETE\s+.*?\+.*?WHERE/gi
        ];
        for (const pattern of sqlInjectionPatterns) {
            const matches = [...content.matchAll(pattern)];
            for (const match of matches) {
                const lineNumber = content.substring(0, match.index).split('\n').length;
                vulnerabilities.push({
                    id: this.generateVulnerabilityId(),
                    type: 'sql_injection',
                    severity: 'high',
                    title: 'Potential SQL Injection',
                    description: 'Dynamic SQL query construction detected. This could lead to SQL injection vulnerabilities.',
                    location: {
                        file: file.uri.fsPath,
                        line: lineNumber,
                        column: match.index - content.lastIndexOf('\n', match.index) - 1
                    },
                    cwe: 'CWE-89',
                    owasp: 'A03:2021 – Injection',
                    evidence: match[0],
                    impact: 'Attackers could execute arbitrary SQL commands, potentially accessing, modifying, or deleting sensitive data.',
                    remediation: {
                        description: 'Use parameterized queries or prepared statements',
                        steps: [
                            'Replace string concatenation with parameterized queries',
                            'Use ORM frameworks that provide built-in SQL injection protection',
                            'Validate and sanitize all user inputs',
                            'Apply principle of least privilege to database connections'
                        ],
                        codeExample: `// Vulnerable code:\nconst query = "SELECT * FROM users WHERE id = " + userId;\n\n// Secure code:\nconst query = "SELECT * FROM users WHERE id = ?";\ndb.execute(query, [userId]);`,
                        automated: false,
                        effort: 'medium',
                        priority: 9
                    },
                    confidence: 85,
                    category: 'injection',
                    references: [
                        'https://owasp.org/www-community/attacks/SQL_Injection',
                        'https://cwe.mitre.org/data/definitions/89.html'
                    ],
                    affectedCode: match[0]
                });
            }
        }
        // XSS patterns
        const xssPatterns = [
            /innerHTML\s*=\s*.*?\+/gi,
            /document\.write\s*\(\s*.*?\+/gi,
            /\.html\s*\(\s*.*?\+/gi,
            /dangerouslySetInnerHTML/gi
        ];
        for (const pattern of xssPatterns) {
            const matches = [...content.matchAll(pattern)];
            for (const match of matches) {
                const lineNumber = content.substring(0, match.index).split('\n').length;
                vulnerabilities.push({
                    id: this.generateVulnerabilityId(),
                    type: 'xss_reflected',
                    severity: 'high',
                    title: 'Potential Cross-Site Scripting (XSS)',
                    description: 'Dynamic HTML content generation detected without proper encoding.',
                    location: {
                        file: file.uri.fsPath,
                        line: lineNumber,
                        column: match.index - content.lastIndexOf('\n', match.index) - 1
                    },
                    cwe: 'CWE-79',
                    owasp: 'A03:2021 – Injection',
                    evidence: match[0],
                    impact: 'Attackers could execute malicious scripts in users\' browsers, steal session tokens, or perform actions on behalf of users.',
                    remediation: {
                        description: 'Encode output and validate inputs',
                        steps: [
                            'Use proper output encoding functions',
                            'Validate and sanitize all user inputs',
                            'Implement Content Security Policy (CSP)',
                            'Use templating engines with automatic escaping'
                        ],
                        codeExample: `// Vulnerable code:\ndocument.innerHTML = userInput;\n\n// Secure code:\ndocument.textContent = userInput;\n// or use a sanitization library`,
                        automated: false,
                        effort: 'medium',
                        priority: 8
                    },
                    confidence: 80,
                    category: 'injection',
                    references: [
                        'https://owasp.org/www-community/attacks/xss/',
                        'https://cwe.mitre.org/data/definitions/79.html'
                    ],
                    affectedCode: match[0]
                });
            }
        }
        return vulnerabilities;
    }
    async runLanguageSpecificAnalysis(file) {
        const vulnerabilities = [];
        switch (file.languageId) {
            case 'javascript':
            case 'typescript':
                vulnerabilities.push(...await this.analyzeJavaScriptSecurity(file));
                break;
            case 'python':
                vulnerabilities.push(...await this.analyzePythonSecurity(file));
                break;
            case 'java':
                vulnerabilities.push(...await this.analyzeJavaSecurity(file));
                break;
            case 'csharp':
                vulnerabilities.push(...await this.analyzeCSharpSecurity(file));
                break;
        }
        return vulnerabilities;
    }
    async analyzeJavaScriptSecurity(file) {
        const vulnerabilities = [];
        const content = file.content;
        const lines = content.split('\n');
        // Hardcoded secrets detection
        const secretPatterns = [
            { pattern: /(?:password|passwd|pwd)\s*[:=]\s*["'](?!.*\$\{).{3,}["']/gi, type: 'hardcoded_password' },
            { pattern: /(?:api[_-]?key|apikey)\s*[:=]\s*["'][a-zA-Z0-9]{20,}["']/gi, type: 'hardcoded_api_key' },
            { pattern: /(?:secret|token)\s*[:=]\s*["'][a-zA-Z0-9+/]{20,}["']/gi, type: 'hardcoded_secret' },
            { pattern: /mongodb\+srv:\/\/[^:]+:[^@]+@/gi, type: 'hardcoded_connection_string' },
            { pattern: /postgres(?:ql)?:\/\/[^:]+:[^@]+@/gi, type: 'hardcoded_connection_string' }
        ];
        for (const { pattern, type } of secretPatterns) {
            const matches = [...content.matchAll(pattern)];
            for (const match of matches) {
                const lineNumber = content.substring(0, match.index).split('\n').length;
                vulnerabilities.push({
                    id: this.generateVulnerabilityId(),
                    type: 'hardcoded_secret',
                    severity: 'critical',
                    title: `Hardcoded Secret: ${type.replace('hardcoded_', '').replace('_', ' ')}`,
                    description: `Hardcoded credentials detected in source code. This exposes sensitive information.`,
                    location: {
                        file: file.uri.fsPath,
                        line: lineNumber,
                        column: match.index - content.lastIndexOf('\n', match.index) - 1
                    },
                    cwe: 'CWE-798',
                    owasp: 'A07:2021 – Identification and Authentication Failures',
                    evidence: match[0].replace(/["'][^"']*["']/, '"***REDACTED***"'),
                    impact: 'Exposed credentials could be used by attackers to gain unauthorized access to systems and data.',
                    remediation: {
                        description: 'Move secrets to environment variables or secure vaults',
                        steps: [
                            'Remove hardcoded credentials from source code',
                            'Use environment variables for configuration',
                            'Implement secure secret management (e.g., Azure Key Vault, AWS Secrets Manager)',
                            'Add secrets to .gitignore patterns',
                            'Rotate compromised credentials immediately'
                        ],
                        codeExample: `// Vulnerable code:\nconst apiKey = "sk-1234567890abcdef";\n\n// Secure code:\nconst apiKey = process.env.API_KEY;`,
                        automated: true,
                        effort: 'low',
                        priority: 10
                    },
                    confidence: 95,
                    category: 'sensitive_data_exposure',
                    references: [
                        'https://owasp.org/www-community/vulnerabilities/Use_of_hard-coded_credentials',
                        'https://cwe.mitre.org/data/definitions/798.html'
                    ],
                    affectedCode: match[0]
                });
            }
        }
        // Insecure random number generation
        if (content.includes('Math.random()')) {
            const matches = [...content.matchAll(/Math\.random\(\)/gi)];
            for (const match of matches) {
                const lineNumber = content.substring(0, match.index).split('\n').length;
                vulnerabilities.push({
                    id: this.generateVulnerabilityId(),
                    type: 'insecure_random',
                    severity: 'medium',
                    title: 'Insecure Random Number Generation',
                    description: 'Math.random() is not cryptographically secure and should not be used for security-sensitive operations.',
                    location: {
                        file: file.uri.fsPath,
                        line: lineNumber,
                        column: match.index - content.lastIndexOf('\n', match.index) - 1
                    },
                    cwe: 'CWE-338',
                    owasp: 'A02:2021 – Cryptographic Failures',
                    evidence: match[0],
                    impact: 'Predictable random numbers could be exploited in security contexts like session tokens or CSRF tokens.',
                    remediation: {
                        description: 'Use cryptographically secure random number generation',
                        steps: [
                            'Replace Math.random() with crypto.randomBytes() for Node.js',
                            'Use crypto.getRandomValues() for browsers',
                            'Use established libraries for generating secure tokens'
                        ],
                        codeExample: `// Vulnerable code:\nconst token = Math.random().toString(36);\n\n// Secure code:\nconst crypto = require('crypto');\nconst token = crypto.randomBytes(32).toString('hex');`,
                        automated: true,
                        effort: 'low',
                        priority: 6
                    },
                    confidence: 90,
                    category: 'cryptography',
                    references: [
                        'https://cwe.mitre.org/data/definitions/338.html'
                    ],
                    affectedCode: match[0]
                });
            }
        }
        return vulnerabilities;
    }
    async analyzePythonSecurity(file) {
        // Python-specific security analysis would be implemented here
        return [];
    }
    async analyzeJavaSecurity(file) {
        // Java-specific security analysis would be implemented here
        return [];
    }
    async analyzeCSharpSecurity(file) {
        // C#-specific security analysis would be implemented here
        return [];
    }
    async runDataFlowAnalysis(file) {
        // Advanced data flow analysis for complex vulnerability detection
        // This would track data from sources (user input) to sinks (sensitive operations)
        const vulnerabilities = [];
        try {
            const functions = this.codeAnalyzer.extractFunctions(file.content, file.languageId);
            for (const func of functions) {
                // Analyze function for data flow patterns
                const sources = this.identifyDataSources(func);
                const sinks = this.identifyDataSinks(func);
                // Check for unsanitized data flow from sources to sinks
                for (const source of sources) {
                    for (const sink of sinks) {
                        if (this.hasUnsanitizedPath(source, sink, func)) {
                            vulnerabilities.push({
                                id: this.generateVulnerabilityId(),
                                type: 'improper_input_validation',
                                severity: 'medium',
                                title: 'Potential Data Flow Vulnerability',
                                description: `Unsanitized data flows from ${source.type} to ${sink.type}`,
                                location: {
                                    file: file.uri.fsPath,
                                    line: func.startLine,
                                    column: 0
                                },
                                cwe: 'CWE-20',
                                evidence: func.signature || func.name,
                                impact: 'User input reaches sensitive operations without proper validation.',
                                remediation: {
                                    description: 'Implement input validation and sanitization',
                                    steps: [
                                        'Validate all user inputs at entry points',
                                        'Sanitize data before using in sensitive operations',
                                        'Use whitelisting instead of blacklisting',
                                        'Implement proper error handling'
                                    ],
                                    automated: false,
                                    effort: 'medium',
                                    priority: 5
                                },
                                confidence: 70,
                                category: 'security_misconfiguration',
                                references: [
                                    'https://cwe.mitre.org/data/definitions/20.html'
                                ],
                                affectedCode: func.signature || func.name
                            });
                        }
                    }
                }
            }
        }
        catch (error) {
            console.warn('Data flow analysis failed:', error);
        }
        return vulnerabilities;
    }
    async enhanceVulnerabilitiesWithAI(vulnerabilities, files) {
        const enhancedVulnerabilities = [];
        // Use AI for complex vulnerability patterns
        for (const file of files.slice(0, 5)) { // Limit AI analysis to prevent quota exhaustion
            try {
                const aiVulns = await this.aiSecurityAnalysis(file);
                enhancedVulnerabilities.push(...aiVulns);
            }
            catch (error) {
                console.warn(`AI analysis failed for ${file.uri.fsPath}:`, error);
            }
        }
        return enhancedVulnerabilities;
    }
    async aiSecurityAnalysis(file) {
        const prompt = `Analyze this ${file.languageId} code for security vulnerabilities:

${file.content}

Focus on:
1. Business logic flaws
2. Complex injection vulnerabilities
3. Authentication/authorization bypasses
4. Race conditions
5. Logic bombs or backdoors
6. Cryptographic issues
7. Session management flaws

Return a JSON array of vulnerabilities found (max 5):
[{
  "type": "vulnerability_type",
  "severity": "critical|high|medium|low",
  "title": "Vulnerability Title",
  "description": "Detailed description",
  "line": 123,
  "evidence": "code snippet",
  "impact": "potential impact",
  "confidence": 85
}]

Only return JSON, no other text.`;
        try {
            const response = await this.echoProvider.getCompletion(prompt, '', file.languageId, 1500);
            const aiResults = JSON.parse(response);
            return aiResults.map((result) => ({
                id: this.generateVulnerabilityId(),
                type: result.type,
                severity: result.severity,
                title: result.title,
                description: result.description,
                location: {
                    file: file.uri.fsPath,
                    line: result.line || 1,
                    column: 0
                },
                evidence: result.evidence,
                impact: result.impact,
                remediation: {
                    description: 'AI-identified vulnerability requiring manual review',
                    steps: ['Review the identified issue', 'Implement appropriate security measures'],
                    automated: false,
                    effort: 'medium',
                    priority: 5
                },
                confidence: result.confidence || 70,
                category: 'business_logic',
                references: [],
                affectedCode: result.evidence
            }));
        }
        catch (error) {
            console.warn('AI security analysis failed:', error);
            return [];
        }
    }
    // Helper methods
    async getWorkspaceFiles() {
        // Get files from codebase indexer
        const stats = this.codebaseIndexer.getStats();
        const files = [];
        // This would be implemented to get actual indexed files
        // For now, return empty array as placeholder
        return files;
    }
    filterFilesForScanning(files, options) {
        return files.filter(file => {
            // Skip test files unless explicitly included
            if (!options?.includeTests && this.isTestFile(file)) {
                return false;
            }
            // Only scan supported file types
            const supportedTypes = ['javascript', 'typescript', 'python', 'java', 'csharp', 'php', 'ruby', 'go'];
            return supportedTypes.includes(file.languageId);
        });
    }
    isTestFile(file) {
        const testPatterns = [/\.test\./, /\.spec\./, /test\//, /tests\//, /__tests__\//];
        return testPatterns.some(pattern => pattern.test(file.uri.fsPath));
    }
    updateScanProgress(progress, status) {
        if (this.currentScan) {
            this.currentScan.progress = progress;
            this.currentScan.status = status;
        }
    }
    generateScanId() {
        return `security_scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    generateVulnerabilityId() {
        return `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    async createVulnerability(rule, file, line, evidence) {
        // Create vulnerability from security rule match
        return {
            id: this.generateVulnerabilityId(),
            type: 'security_misconfiguration', // Default type
            severity: rule.severity,
            title: rule.name,
            description: rule.description,
            location: {
                file: file.uri.fsPath,
                line,
                column: 0
            },
            evidence,
            impact: 'Security rule violation detected',
            remediation: {
                description: `Address ${rule.name}`,
                steps: ['Review and fix the security issue'],
                automated: false,
                effort: 'medium',
                priority: 5
            },
            confidence: 80,
            category: rule.category,
            references: [],
            affectedCode: evidence
        };
    }
    deduplicateVulnerabilities(vulnerabilities) {
        const unique = new Map();
        for (const vuln of vulnerabilities) {
            const key = `${vuln.type}_${vuln.location.file}_${vuln.location.line}`;
            if (!unique.has(key) || unique.get(key).confidence < vuln.confidence) {
                unique.set(key, vuln);
            }
        }
        return Array.from(unique.values());
    }
    generateSummary(vulnerabilities) {
        return {
            total: vulnerabilities.length,
            critical: vulnerabilities.filter(v => v.severity === 'critical').length,
            high: vulnerabilities.filter(v => v.severity === 'high').length,
            medium: vulnerabilities.filter(v => v.severity === 'medium').length,
            low: vulnerabilities.filter(v => v.severity === 'low').length,
            info: vulnerabilities.filter(v => v.severity === 'info').length
        };
    }
    calculateRiskScore(vulnerabilities) {
        const weights = { critical: 10, high: 7, medium: 4, low: 2, info: 1 };
        const totalScore = vulnerabilities.reduce((sum, v) => sum + weights[v.severity], 0);
        return Math.min(100, totalScore);
    }
    assessCompliance(vulnerabilities) {
        // Simplified compliance assessment
        const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
        const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
        return {
            owasp: criticalCount === 0 && highCount < 5,
            pci: criticalCount === 0 && highCount < 3,
            gdpr: criticalCount === 0,
            hipaa: criticalCount === 0 && highCount < 2
        };
    }
    async countEndpoints(files) {
        let endpointCount = 0;
        for (const file of files) {
            if (file.content) {
                // Count REST endpoints, route definitions, etc.
                const endpointPatterns = [
                    /app\.(get|post|put|delete|patch)/gi,
                    /router\.(get|post|put|delete|patch)/gi,
                    /@(Get|Post|Put|Delete|Patch)Mapping/gi,
                    /route\s*\(/gi
                ];
                for (const pattern of endpointPatterns) {
                    const matches = file.content.match(pattern);
                    endpointCount += matches ? matches.length : 0;
                }
            }
        }
        return endpointCount;
    }
    identifyDataSources(func) {
        // Identify data sources like user input, request parameters, etc.
        const sources = [];
        const sourcePatterns = ['req.body', 'req.query', 'req.params', 'process.argv', 'input()', 'gets()'];
        // This would be more sophisticated in a real implementation
        return sources;
    }
    identifyDataSinks(func) {
        // Identify data sinks like database queries, file operations, etc.
        const sinks = [];
        const sinkPatterns = ['execute(', 'query(', 'eval(', 'system(', 'exec('];
        // This would be more sophisticated in a real implementation
        return sinks;
    }
    hasUnsanitizedPath(source, sink, func) {
        // Check if there's an unsanitized path between source and sink
        // This would involve complex control flow analysis
        return false; // Placeholder
    }
    initializeSecurityRules() {
        // Initialize comprehensive security rules database
        this.securityRules.set('hardcoded_password', {
            id: 'hardcoded_password',
            name: 'Hardcoded Password',
            description: 'Hardcoded credentials detected in source code',
            category: 'sensitive_data_exposure',
            severity: 'critical',
            pattern: /(?:password|passwd|pwd)\s*[:=]\s*["'].{3,}["']/gi,
            languages: ['javascript', 'typescript', 'python', 'java', 'csharp'],
            enabled: true,
            aiEnhanced: true
        });
        // Add more security rules...
        this.addDefaultSecurityRules();
    }
    addDefaultSecurityRules() {
        // This would add a comprehensive set of security rules
        // covering OWASP Top 10 and other common vulnerabilities
    }
    // Public interface methods
    getCurrentScanProgress() {
        return this.currentScan;
    }
    getScanResult(scanId) {
        return this.scanResults.get(scanId);
    }
    getLatestScanResult() {
        const results = Array.from(this.scanResults.values());
        return results.sort((a, b) => b.timestamp - a.timestamp)[0];
    }
    clearScanResults() {
        this.scanResults.clear();
    }
}
exports.VulnerabilityScanner = VulnerabilityScanner;
//# sourceMappingURL=VulnerabilityScanner.js.map